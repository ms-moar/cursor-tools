# –î–ï–¢–ê–õ–¨–ù–´–ô –û–¢–ß–ï–¢ –ü–û –ò–ù–¢–ï–ì–†–ê–¶–ò–ò –õ–û–ì–ò–ö MOAR-LOGICS

**–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ç—á–µ—Ç–∞:** 2024-12-19  
**–í–µ—Ä—Å–∏—è —Å–∏—Å—Ç–µ–º—ã:** Memory Bank v0.7-beta  
**–°—Ç–∞—Ç—É—Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏:** –ó–ê–í–ï–†–®–ï–ù–ê

## –û–ë–©–ò–ô –ü–û–î–•–û–î –ò –ü–†–ò–ù–¶–ò–ü–´ –ò–ù–¢–ï–ì–†–ê–¶–ò–ò

–í—Å–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏–ª–∏—Å—å –ø—É—Ç–µ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏–ª–∏ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø—Ä–∞–≤–∏–ª –≤ –ø–∞–ø–∫–µ `.cursor/rules/isolation_rules/`. –ù–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞ —Å–æ–∑–¥–∞–≤–∞–ª–∏—Å—å —Ç–æ–ª—å–∫–æ –¥–ª—è –ª–æ–≥–∏–∫–∏ DeepSeek, –∫–∞–∫ –±—ã–ª–æ —É–∫–∞–∑–∞–Ω–æ –≤ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è—Ö. –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º —è–∑—ã–∫–µ, —Å–æ—Ö—Ä–∞–Ω—è—è —Ç–µ–∫—É—â–∏–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–∞–≤–∏–ª (Markdown —Å –¥–∏–∞–≥—Ä–∞–º–º–∞–º–∏ Mermaid).

**–ü—Ä–∏–Ω—Ü–∏–ø—ã –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏:**
- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ –ø—Ä–∞–≤–∏–ª.
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ —è–∑—ã–∫–∞ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ –ø—Ä–∞–≤–∏–ª.
- –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤.
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∏–µ—Ä–∞—Ä—Ö–∏—é –ø—Ä–∞–≤–∏–ª.

---

## 1. –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –õ–û–ì–ò–ö–ò DEEPSEEK (`moar-logics/deepseek-integration.mdc`)

### 1.1 –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ –ø—Ä–∞–≤–∏–ª–∞ DeepSeek

**–§–∞–π–ª:** `.cursor/rules/isolation_rules/Core/deepseek-integration.mdc`

**–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ (–ø–æ–ª–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –Ω–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞):**
```markdown
---
description: DeepSeek LLM Integration Logic for Memory Bank
globs: "**/deepseek-integration.mdc"
alwaysApply: false
---

# DEEPSEEK LLM INTEGRATION

> **TL;DR:** This rule defines how to interact with DeepSeek LLMs, including model selection based on task complexity, API request formatting, and robust error handling, ensuring optimized and reliable LLM interactions.

## üß≠ DEEPSEEK INTEGRATION STRATEGY

This system provides guidelines for selecting the appropriate DeepSeek model, constructing API requests, and handling potential errors to ensure efficient and effective LLM utilization.

```mermaid
graph TD
    Start["Task Input / User Query"] --> AssessComplexity{"1. Assess Task Complexity<br>(Level 1-4 from activeContext.md)"}
    AssessComplexity -- "Levels 1-2 (Simple Queries, Summaries)" --> SelectChat["2a. Select 'deepseek-chat'"]
    AssessComplexity -- "Levels 3-4 (Complex Code, Analysis, Detailed Docs)" --> SelectCoder["2b. Select 'deepseek-coder'"]
    SelectChat --> PrepareRequest["3. Prepare API Request<br>(Model, Messages, Parameters)"]
    SelectCoder --> PrepareRequest
    PrepareRequest --> CallAPI["4. Call DeepSeek API<br>(mcp_deepseek_call_api - *hypothetical tool*) "]
    CallAPI --> HandleResponse{"5. Handle API Response"}
    HandleResponse -- Success --> ProcessOutput["6a. Process Successful Output"]
    HandleResponse -- Error --> HandleError["6b. Implement Error Handling<br>(Retry, Log, Notify)"]
    ProcessOutput --> FinalOutput["7. Final Output to User/Next Step"]
    HandleError --> FinalOutput
```

## üß† MODEL SELECTION CRITERIA

The choice of DeepSeek model is critical for performance and cost-effectiveness.

*   **`deepseek-chat`**:
    *   **Use Cases**: General conversation, text summarization, simple question answering, content generation for Level 1-2 tasks, initial brainstorming.
    *   **Strengths**: Faster response times, lower cost for simpler tasks.
    *   **Activation**: Default for tasks determined as Level 1 or Level 2 complexity via `complexity-decision-tree.mdc`.

*   **`deepseek-coder`**:
    *   **Use Cases**: Code generation, complex problem solving, detailed technical documentation, architectural analysis, Level 3-4 tasks.
    *   **Strengths**: Advanced reasoning, strong coding capabilities, better understanding of complex contexts.
    *   **Activation**: Default for tasks determined as Level 3 or Level 4 complexity.

**Workflow for Model Selection:**
1.  Identify task complexity based on `activeContext.md` or by applying `complexity-decision-tree.mdc`.
2.  If complexity is Level 1 or 2, select `deepseek-chat`.
3.  If complexity is Level 3 or 4, select `deepseek-coder`.
4.  Provide an override mechanism if a specific model is requested by the user or deemed more appropriate by the AI based on nuanced understanding of the query.

## ‚öôÔ∏è API INTERACTION PROTOCOL

### API Request Structure (Illustrative)

*(Assuming a hypothetical `mcp_deepseek_call_api` tool)*
```json
{
  "model": "deepseek-chat", // or "deepseek-coder"
  "messages": [
    {"role": "system", "content": "You are a helpful AI assistant integrated into a Memory Bank system. Current active context: [Context Summary from activeContext.md]. Task Level: [1-4]."},
    {"role": "user", "content": "User's specific query or instruction."}
  ],
  "max_tokens": 2048,       // Adjust based on expected output
  "temperature": 0.7,       // Lower for precision, higher for creativity
  "stream": false           // Or true if streaming is supported and needed
}
```
*   **System Prompt**: Should be dynamically populated with key information from `activeContext.md` (e.g., current project, task level, relevant file paths) to provide DeepSeek with necessary context.
*   **User Content**: The specific request or problem statement.
*   **Parameters**:
    *   `max_tokens`: Carefully calculated to avoid truncation.
    *   `temperature`: Adjusted based on the nature of the task (e.g., 0.2 for code generation, 0.7-1.0 for creative text).

### Error Handling and Retry Logic

Robust error handling is essential for reliable DeepSeek integration.

```mermaid
graph TD
    APICall["API Call to DeepSeek"] --> CheckResponse{"Response Received?"}
    CheckResponse -- No (Timeout/Network Error) --> Retry1["Retry 1 (after 2s)"]
    CheckResponse -- Yes --> CheckStatus{"HTTP Status Code?"}
    
    CheckStatus -- "200 OK" --> Success["Process Response"]
    CheckStatus -- "400 Bad Request" --> LogError400["Log: Invalid Request Payload<br>Action: Review prompt/payload structure. Do NOT retry immediately."]
    CheckStatus -- "401 Unauthorized" --> LogError401["Log: Authentication Failed<br>Action: Verify API Key. Notify Admin. Do NOT retry."]
    CheckStatus -- "429 Rate Limit Exceeded" --> RetryBackoff1["Log: Rate Limit Hit<br>Retry with Exponential Backoff (e.g., 5s, 15s, 30s)"]
    CheckStatus -- "5xx Server Error" --> RetryBackoffSrv1["Log: Server Error<br>Retry with Exponential Backoff (e.g., 10s, 30s, 60s)"]
    CheckStatus -- "Other Error" --> LogErrorOther["Log: Unexpected Error<br>Action: Document error, consider general retry if appropriate."]

    Retry1 --> CheckResponse
    RetryBackoff1 --> CheckResponse
    RetryBackoffSrv1 --> CheckResponse
    
    LogError400 --> Failure["Report Failure to User/System"]
    LogError401 --> Failure
    LogErrorOther --> Failure
```
*   **Retry Strategy**: Implement exponential backoff for transient errors (rate limits, server errors).
*   **Logging**: Detailed logging of requests, responses, and errors.
*   **User Notification**: Inform the user appropriately in case of persistent failures.

## üí° OPTIMIZATION AND BEST PRACTICES

1.  **Contextual Prompts**: Always enrich prompts with relevant data from `activeContext.md`, `tasks.md`, and other Memory Bank files to improve response quality.
2.  **Chunking for Large Inputs/Outputs**: For very large codebases or documents, break down the task into smaller, manageable chunks for DeepSeek to process.
3.  **Instruction Precision**: Be explicit in prompts about the desired output format (e.g., "Provide the output as a JSON object with keys 'summary' and 'action_items'.").
4.  **Token Management**: Monitor token usage. Design prompts to be concise while providing necessary detail. Estimate output token needs to set `max_tokens` appropriately.
5.  **Few-Shot Prompting**: For complex or nuanced tasks, provide 1-2 examples (shots) in the prompt to guide the model's response.
6.  **User Feedback Loop**: Where possible, incorporate a mechanism for users to rate the quality of DeepSeek's responses, which can be used to refine prompts or strategies over time.

This integration aims to make DeepSeek a powerful and reliable tool within the Memory Bank ecosystem.
```

### 1.2 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π

**–§–∞–π–ª:** `.cursor/rules/isolation_rules/Core/optimization-integration.mdc`

**–ö–æ–Ω—Ç–µ–∫—Å—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–¥–∞:**
```javascript
// ... (other optimization components) ...
  level1Optimization: {
    file: "Level1/optimized-workflow-level1.mdc",
    dependencies: ["adaptiveComplexityModel"],
    priority: 4
  },
  
  // Feature-specific optimizations
  creativePhaseOptimization: {
    file: "Phases/CreativePhase/optimized-creative-template.mdc",
    dependencies: ["hierarchicalRuleLoading", "adaptiveComplexityModel"],
    priority: 5
  },
  
  // Integration optimizations
  // ... (potentially other integrations) ...
```

**–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ (–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ `deepseekIntegration`):**
```javascript
  deepseekIntegration: {
    file: "Core/deepseek-integration.mdc",
    dependencies: ["hierarchicalRuleLoading"],
    priority: 6,
    triggers: ["–¥–∏–ø—Å–∏–∫", "deepseek", "–∏—Å–ø–æ–ª—å–∑—É–π –¥–∏–ø—Å–∏–∫", "—á–µ—Ä–µ–∑ –¥–∏–ø—Å–∏–∫", "—Å –ø–æ–º–æ—â—å—é –¥–∏–ø—Å–∏–∫–∞"]
  }
```
**–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:** –≠—Ç–∞ –∑–∞–ø–∏—Å—å —É–∂–µ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–æ–≤–∞–ª–∞ –∏ –±—ã–ª–∞ –ø—Ä–∏–∑–Ω–∞–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π.

### 1.3 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞

**–§–∞–π–ª:** `integration_config.md`

**–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ (–¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –Ω–æ–≤–∞—è —Å–µ–∫—Ü–∏—è):**

*   –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–∞–∂–¥—ã–π —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π `Project Context` (–ø—Ä–∏–º–µ—Ä –¥–ª—è –æ–¥–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞):
    ```yaml
    # ... (existing context fields like context_name, jira_project_key, etc.) ...
    deepseek_api_key: "–≤–∞—à_—Ä–µ–∞–ª—å–Ω—ã–π_–∫–ª—é—á_–∑–¥–µ—Å—å" # NEW FIELD
    deepseek_model: "deepseek-reasoner"      # NEW FIELD
    # ... (other existing fields like jira_login) ...
    ```

*   –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π —Å–µ–∫—Ü–∏–∏ `## DeepSeek AI Integration`:
    ```yaml
    ## DeepSeek AI Integration
    
    ### –ú–æ–¥–µ–ª–∏
    - `deepseek-chat`: –û–±—â–µ–Ω–∏–µ –∏ –∞–Ω–∞–ª–∏–∑
    - `deepseek-coder`: –ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ
    - `deepseek-reasoner`: –°–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏
    
    ### –î–ª—è –ò–ò
    - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —á–∏—Ç–∞—Ç—å API –∫–ª—é—á –∏–∑ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø—Ä–æ–µ–∫—Ç–∞
    - –í—ã–±–∏—Ä–∞—Ç—å –º–æ–¥–µ–ª—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∑–∞–¥–∞—á–∏
    - –ü—Ä–∏ –æ—à–∏–±–∫–∞—Ö API —Å–æ–æ–±—â–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    ```

### 1.4 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–ª–∞–≤–Ω–æ–≥–æ README

**–§–∞–π–ª:** `README.md`

**–î–æ–±–∞–≤–ª–µ–Ω–Ω–∞—è —Å–µ–∫—Ü–∏—è:**
```markdown
## –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å DeepSeek AI

Memory Bank v0.7-beta –≤–∫–ª—é—á–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å –º–æ–¥–µ–ª—è–º–∏ DeepSeek AI. –ö–æ–≥–¥–∞ –≤—ã —É–ø–æ–º–∏–Ω–∞–µ—Ç–µ "–¥–∏–ø—Å–∏–∫" –∏–ª–∏ "deepseek" –≤ –ª—é–±–æ–º —Ä–µ–∂–∏–º–µ, —Å–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏:

1. **–ß–∏—Ç–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é** –∏–∑ `integration_config.md`
2. **–í—ã–±–∏—Ä–∞–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â—É—é –º–æ–¥–µ–ª—å** –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∑–∞–¥–∞—á–∏:
   - `deepseek-coder` –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–¥–∞ –∏ –æ—Ç–ª–∞–¥–∫–∏
   - `deepseek-chat` –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏  
   - `deepseek-reasoner` –¥–ª—è —Ä–µ—à–µ–Ω–∏—è —Å–ª–æ–∂–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º
3. **–ò—Å–ø–æ–ª—å–∑—É–µ—Ç –≤–∞—à–∏ API —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ** –±–µ–∑–æ–ø–∞—Å–Ω–æ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏

### –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

```
"–î–∞–≤–∞–π —Å–¥–µ–ª–∞–µ–º —ç—Ç–æ —á–µ—Ä–µ–∑ –¥–∏–ø—Å–∏–∫"
"–ò—Å–ø–æ–ª—å–∑—É–π –¥–∏–ø—Å–∏–∫ –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–¥–∞"
"–° –ø–æ–º–æ—â—å—é –¥–∏–ø—Å–∏–∫–∞ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É"
```
```

---

## 2. –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –õ–û–ì–ò–ö–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨–Æ (`moar-logics/security-management.mdc`)

### 2.1 –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –ø—Ä–∞–≤–∏–ª–∞

**–§–∞–π–ª:** `.cursor/rules/isolation_rules/main.mdc`

**–†–∞–∑–¥–µ–ª:** `## üîí MANDATORY SECURITY RULES`

**–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:**

1. **Automatic Backup Creation Procedure:**
```markdown
### 1. Automatic Backup Creation Procedure

**MANDATORY BACKUP WORKFLOW:**

1. **Pre-Operation Check:**
   - Before ANY file modification or deletion, check if `backup-files/` directory exists
   - If not exists, create `backup-files/` directory automatically

2. **Backup Creation:**
   - Generate timestamp: `YYYYMMDDHHMMSS` format
   - Create backup filename: `{original_filename}_{timestamp}.bak`
   - Copy original file to `backup-files/{backup_filename}`
   - Verify backup creation success

3. **Operation Execution:**
   - Only proceed with original operation after successful backup
   - Log backup creation in operation audit trail

4. **Backup Verification:**
   - Verify backup file exists and is readable
   - Compare file sizes (original vs backup)
   - Log verification results
```

2. **File Access Control Rules:**
```markdown
### 2. File Access Control Rules

**FILE CLASSIFICATION AND ACCESS RULES:**

1. **System Files (.cursor/, .git/, node_modules/, etc.):**
   - READ: Allowed for analysis and understanding
   - MODIFY: Requires explicit user confirmation
   - DELETE: Prohibited without explicit user command

2. **Memory Bank Files (memory-bank/):**
   - READ: Always allowed
   - MODIFY: Allowed with automatic backup
   - DELETE: Requires user confirmation + backup

3. **User Project Files:**
   - READ: Always allowed
   - MODIFY: Allowed with automatic backup
   - DELETE: Requires user confirmation + backup

4. **Backup Files (backup-files/):**
   - READ: Always allowed
   - MODIFY: Prohibited
   - DELETE: Requires explicit user command
```

3. **Security Validation for Operations:**
```markdown
### 3. Security Validation for Operations

**PRE-OPERATION SECURITY CHECKS:**

1. **Backup Validation:**
   - Verify backup was created successfully
   - Check backup file integrity
   - Confirm backup location is accessible

2. **User Confirmation for Destructive Operations:**
   - File deletion operations
   - Bulk file modifications
   - System configuration changes
   - Operations affecting multiple files

3. **Path Validation:**
   - Verify file paths are within project boundaries
   - Check for path traversal attempts
   - Validate write permissions

4. **Destructive Command Detection:**
   - Scan commands for destructive patterns (rm, del, format, etc.)
   - Require explicit confirmation for destructive commands
   - Log all destructive operations
```

### 2.2 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª–∞ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Ñ–∞–π–ª–æ–≤

**–§–∞–π–ª:** `.cursor/rules/isolation_rules/Core/file-verification.mdc`

**–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π —Ä–∞–∑–¥–µ–ª:** `## üõ°Ô∏è FILE INTEGRITY AND SYNTAX VALIDATION SYSTEM`

**–ö–ª—é—á–µ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:**

1. **File Integrity Check (SHA-256):**
```markdown
**Procedure:**

1. **Generate Checksum (Hypothetical Tool: `mcp_generate_checksum`):**
   - Input: `target_file` (string)
   - Output: `sha256_checksum` (string)
   - Example: `mcp_generate_checksum --file "memory-bank/projectbrief.md"`

2. **Store Checksum:**
   - Checksums stored in `memory-bank/checksums.sha256`
   - Format: `<checksum>  <filepath>`

3. **Verify Checksum (Hypothetical Tool: `mcp_verify_checksum`):**
   - Input: `target_file` (string), `expected_checksum` (string)
   - Output: `is_valid` (boolean), `message` (string)
```

2. **File Syntax Validation:**
```markdown
**Supported File Types & Validation Methods:**

- **JSON (`*.json`):** Standard JSON parser validation
- **YAML (`*.yaml`, `*.yml`):** YAML library parsing
- **Markdown (`*.md`, `*.mdc`):** Structural issues check, Mermaid diagram syntax
- **Shell Scripts (`*.sh`, `*.ps1`):** shellcheck/PSScriptAnalyzer validation
```

3. **Workflow –¥–∏–∞–≥—Ä–∞–º–º–∞:**
```mermaid
graph TD
    StartVerify["Start File Integrity Check"] --> GetStoredCS["1. Retrieve Stored Checksum"]
    GetStoredCS --> GenerateNewCS["2. Generate Current Checksum"]
    GenerateNewCS --> CompareCS{"3. Compare Checksums"}
    CompareCS -- Match --> Valid["File Integrity VERIFIED"]
    CompareCS -- Mismatch --> Invalid["File Integrity FAILED"]
    Invalid --> AlertUser["4. Alert User & Log Discrepancy"]
    Valid --> ProceedOp["Proceed with Operation"]
```

### 2.3 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥

**–§–∞–π–ª:** `.cursor/rules/isolation_rules/Core/command-execution.mdc`

**–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π —Ä–∞–∑–¥–µ–ª:** `## üìã COMMAND AND FILE OPERATION AUDITING`

**–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∞—É–¥–∏—Ç–∞:**

1. **Audit Log Requirements:**
```markdown
**Each audit log entry MUST include:**

- **Timestamp**: `YYYY-MM-DD HH:MM:SS UTC`
- **Operation Type**: e.g., `CMD_EXEC`, `FILE_CREATE`, `FILE_EDIT`, `FILE_DELETE`, `API_CALL`
- **Command/Operation Details**: The exact command executed
- **Parameters**: Key parameters used
- **Executor**: `AI (Agent Version X.Y)` or `User`
- **Context**: Current active project context name or ID
- **Outcome**: `SUCCESS`, `FAILURE`, `USER_CANCELLED`
- **Result/Output Summary**: Brief summary of the output
- **Affected Resources**: List of files/resources created, modified, or deleted
```

2. **Example Audit Log Entry:**
```markdown
- **Timestamp**: 2024-05-17 10:30:00 UTC
- **Operation Type**: `FILE_EDIT`
- **Details**: `edit_file on .cursor/rules/main.mdc`
- **Executor**: `AI (Agent 2.1)`
- **Context**: `ProjectAlpha_MainContext`
- **Outcome**: `SUCCESS`
- **Result Summary**: "Expanded MANDATORY SECURITY RULES section."
- **Affected Resources**: `.cursor/rules/main.mdc` (modified)
---
- **Timestamp**: 2024-05-17 10:35:15 UTC
- **Operation Type**: `CMD_EXEC`
- **Details**: `git commit -m "Update security rules"`
- **Executor**: `AI (Agent 2.1)`
- **Context**: `ProjectAlpha_MainContext`
- **Outcome**: `SUCCESS`
- **Result Summary**: "[main abc1234] Update security rules. 1 file changed."
- **Affected Resources**: Git repository
```

3. **Operations to Audit:**
```markdown
- All `run_terminal_cmd` executions
- All `edit_file` operations
- All `create_file` operations
- All `delete_file` operations
- Significant API Calls (Jira, DeepSeek, etc.)
- Security-Related Events (backup creation, integrity check failures, etc.)
```

---

## 3. –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –õ–û–ì–ò–ö–ò ATLASSIAN (JIRA/CONFLUENCE) (`moar-logics/atlassian-integration.mdc`)

### 3.1 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö –∫–∞—Ä—Ç –ø—Ä–æ—Ü–µ—Å—Å–æ–≤

#### 3.1.1 Plan Mode Map

**–§–∞–π–ª:** `.cursor/rules/isolation_rules/visual-maps/plan-mode-map.mdc`

**–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —à–∞–≥–∏:**

1. **Step 1: Auto-Sync Tasks (Jira & tasks.md):**
```markdown
### Step 1: Auto-Sync Tasks (Jira & tasks.md)
*   **(Optional) Action**: Read `tasks.md` line by line.
    *   For each line, parse `JIRA_PROJECT_KEY`, `JIRA_ISSUE_ID`, current local status, and current local Story Points (e.g., from a pattern like `SP_VALUE=[X]`).
    *   Find the corresponding `Project Context` in `integration_config.md` using `JIRA_PROJECT_KEY`. Let this be `taskSpecificContext`.
    *   If `taskSpecificContext` is found:
        *   Let `fieldsToFetch = ["status"]`.
        *   If `taskSpecificContext.jira_sp_field_id` is defined, add `taskSpecificContext.jira_sp_field_id` to `fieldsToFetch`.
        *   Call `mcp_mcp-atlassian_jira_get_issue` for `JIRA_ISSUE_ID` in its specific project, requesting `fieldsToFetch`.
        *   Let `jiraStatus = result.status.name` (or ID).
        *   Let `jiraSpValue = result.fields[taskSpecificContext.jira_sp_field_id]` if present and `jira_sp_field_id` was fetched.
        *   Let `lineToUpdate = false` and `updatedLineContent = original_line_from_tasks_md`.
        *   Compare `jiraStatus` with local status. If different and `jiraStatus` is a "completed" one (e.g., matches `ARCHIVE` or `REFLECT` status in `taskSpecificContext.jira_status_mapping`), mark task for update to `[x]` in `updatedLineContent` and set `lineToUpdate = true`.
        *   If `jiraSpValue` is available and different from local Story Points (or local SP is missing):
            *   Update `updatedLineContent` to include/replace the SP part (e.g., `SP_VALUE=[jiraSpValue]`). Ensure format matches `integration_config.md`. Set `lineToUpdate = true`.
        *   If `lineToUpdate` is true, propose `edit_file` for `tasks.md` to replace the original line with `updatedLineContent`.
    *   **Report**: Briefly report sync results, including SP updates if any.
```

2. **Step 5.1: Process Epics & Tasks for Jira Creation:**
```markdown
### Step 5.1: Process Epics & Tasks for Jira Creation (using selected context)
*   **Action**: Initialize an empty list `createdOrUpdatedJiraIssues = []` to store details of issues successfully processed with Jira.
*   **Action**: Determine the initial Jira status for new issues. If `activeProjectContext.jira_status_mapping` exists and has a mapping for a "new" or "todo" equivalent status (e.g., `activeProjectContext.jira_status_mapping.PLAN.start`), use that target status ID. Otherwise, Jira will use its project default.
*   **Action**: For each Epic in the plan from Step 4 (`epicName`, and its list of tasks with their SP estimates):
    *   Let `totalEpicSP = sum of SP estimates for all tasks in this epic`.
    *   If `totalEpicSP < 7` (small epic threshold):
        *   **Consolidate Epic**: Create a single Jira issue for the entire epic instead of separate epic + tasks.
        *   Let `consolidatedTitle = epicName`.
        *   Let `consolidatedDescription = "Epic: " + epicName + "\n\nTasks:\n" + (formatted list of all tasks with their SP estimates and descriptions)`.
        *   Let `consolidatedSP = totalEpicSP`.
        *   Call `mcp_mcp-atlassian_jira_create_issue` with:
            *   `project_key = activeProjectContext.jira_project_key`
            *   `issue_type = activeProjectContext.jira_default_issue_type` (e.g., "Story")
            *   `summary = consolidatedTitle`
            *   `description = consolidatedDescription + "\n\n–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞ —Å –ø–æ–º–æ—â—å—é –ò–ò."`
            *   `labels = ["created-by-ai"] + activeProjectContext.jira_default_labels` (if defined)
            *   If `activeProjectContext.jira_sp_field_id` is defined: `custom_fields = {activeProjectContext.jira_sp_field_id: consolidatedSP}`
            *   If `activeProjectContext.jira_component != "NO_NAME"`: `components = [activeProjectContext.jira_component]`
            *   If `activeProjectContext.jira_assignee_default` is defined: `assignee = activeProjectContext.jira_assignee_default`
        *   Add the created issue details to `createdOrUpdatedJiraIssues`.
    *   Else (large epic, `totalEpicSP >= 7`):
        *   **Create Epic**: Call `mcp_mcp-atlassian_jira_create_issue` for the epic with `issue_type = "Epic"`.
        *   **Create Individual Tasks**: For each task in the epic, call `mcp_mcp-atlassian_jira_create_issue` with `issue_type = activeProjectContext.jira_default_issue_type` and link it to the epic.
```

#### 3.1.2 Implement Mode Map

**–§–∞–π–ª:** `.cursor/rules/isolation_rules/visual-maps/implement-mode-map.mdc`

**–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —à–∞–≥–∏:**

1. **Step 1: Auto-Sync tasks.md with Jira:**
```markdown
### Step 1: Auto-Sync tasks.md with Jira (for all contexts)
*   **Action**: Read `tasks.md` line by line.
    *   For each line, parse `JIRA_PROJECT_KEY_FROM_TASK`, `JIRA_ISSUE_ID_FROM_TASK`, `CONTEXT_NAME_FROM_TASK`, current local status checkbox `[ ]` or `[x]`, and current local Story Points (e.g., from `SP_VALUE=[X]`).
    *   Find the corresponding `Project Context` in `integration_config.md` using `CONTEXT_NAME_FROM_TASK` or `JIRA_PROJECT_KEY_FROM_TASK`. Let this be `taskSpecificContext`.
    *   If `taskSpecificContext` found:
        *   Let `fieldsToFetch = ["status"]`.
        *   If `taskSpecificContext.jira_sp_field_id` is defined, add `taskSpecificContext.jira_sp_field_id` to `fieldsToFetch`.
        *   Call `mcp_mcp-atlassian_jira_get_issue` for `JIRA_ISSUE_ID_FROM_TASK` in its specific project, requesting `fieldsToFetch`.
        *   Let `jiraStatus = result.status.name` (or ID).
        *   Let `jiraSpValue = result.fields[taskSpecificContext.jira_sp_field_id]` if present and `jira_sp_field_id` was fetched.
        *   Compare `jiraStatus` with the local status in `tasks.md` and `jiraSpValue` with local SP.
        *   If there are discrepancies, update `tasks.md` to reflect the Jira state, or prompt the user about the differences.
```

2. **Step 3: Check Jira Status/Assignee & Propose Updates:**
```markdown
### Step 3: Check Jira Status/Assignee & Propose Updates (for selected task in its context)
*   **Action**: Call `mcp_mcp-atlassian_jira_get_issue` for `selectedJiraIssueKey` (fields: status, assignee, labels, description). Let `currentJiraStatus = result.status.name`, `currentJiraStatusId = result.status.id`, `currentAssignee = result.assignee`, `currentLabels = result.labels`, `currentDescription = result.description`.
*   **Action**: Let `implementTargetStatusMapping = selectedJiraStatusMapping.IMPLEMENT` (this should contain `target_status_name`, `target_status_id`, and `allowed_from_statuses_names` or `allowed_from_statuses_ids` for the `activeProjectContext`).
*   **Action**: Let `targetImplementStatusName = implementTargetStatusMapping.target_status_name`.
*   **Action**: Let `targetImplementStatusId = implementTargetStatusMapping.target_status_id`.
*   **Action**: Let `allowedFromImplement = implementTargetStatusMapping.allowed_from_statuses_names` (or `allowed_from_statuses_ids`).

*   **Condition**: If `currentJiraStatus` is `targetImplementStatusName` (or `currentJiraStatusId` is `targetImplementStatusId`):
    *   **Report**: "STOP: Task [selectedJiraIssueKey] is already in '[targetImplementStatusName]' but assigned to [currentAssignee]. Please reassign or pick another task."
    *   **Action**: End IMPLEMENT mode or return to task selection.

*   **Condition**: If `currentJiraStatus` is NOT `targetImplementStatusName` (or `currentJiraStatusId` is NOT `targetImplementStatusId`):
    *   **Condition**: If `currentJiraStatus` is NOT in `allowedFromImplement` (check by name or ID):
        *   **Report**: "WARNING: Current Jira status '[currentJiraStatus]' for [selectedJiraIssueKey] is not in the allowed list to transition to '[targetImplementStatusName]' ([allowedFromImplement]). Manual Jira status update might be needed first or an intermediate transition."
        *   **Action**: Ask user if they want to attempt the transition anyway.
        *   If user declines, skip automated transition.

*   **Action**: (If proceeding) Call `mcp_mcp-atlassian_jira_transition_issue` with `issue_key=selectedJiraIssueKey` and `transition_id=targetImplementStatusId` (or `transition_name=targetImplementStatusName`).
*   **Report**: "Jira issue [selectedJiraIssueKey] transitioned to [targetImplementStatusName]."
*   **Condition**: If `activeProjectContext.jira_add_comment_on_archive` is true:
    *   **Action**: Let `archiveComment = activeProjectContext.jira_archive_comment_template` (e.g., "Task archived. See Confluence: [confluencePageUrl], GitLab Tag: [gitLabTagUrl]"). Replace placeholders.
    *   **Action**: Call `mcp_mcp-atlassian_jira_add_comment` with `issue_key=selectedJiraIssueKey` and `comment_body=archiveComment`.
    *   **Report**: "Comment added to Jira issue [selectedJiraIssueKey]."
*   **Condition**: If `activeProjectContext.jira_update_resolution_on_archive` is true AND `activeProjectContext.jira_resolution_name_for_archive` (e.g., "Done", "Fixed") is defined:
    *   **Action**: Call `mcp_mcp-atlassian_jira_update_issue_resolution` with `issue_key=selectedJiraIssueKey` and `resolution_name=activeProjectContext.jira_resolution_name_for_archive`.
    *   **Report**: "Resolution for Jira issue [selectedJiraIssueKey] set to '[activeProjectContext.jira_resolution_name_for_archive]'."
*   **Error Handling**: Report any errors from Jira API calls.
```

3. **Step 3.2: AI Task Validation:**
```markdown
### Step 3.2: AI Task Validation (for selected task in its context)
*   **Action**: Check if `currentLabels` contains "created-by-ai" or "edited-by-ai", OR if `currentDescription` contains "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞ —Å –ø–æ–º–æ—â—å—é –ò–ò." or "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ó–∞–¥–∞—á–∞ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∞ —Å –ø–æ–º–æ—â—å—é –ò–ò.".
*   **Action**: If neither AI marker is found:
    *   **AI Task Validation Required**: The task was not created or previously edited by AI, so we need to validate our understanding.
    *   Present interpretation focusing on implementation aspects:
        ```
        ü§ñ –°–û–ì–õ–ê–°–û–í–ê–ù–ò–ï –ó–ê–î–ê–ß–ò [selectedJiraIssueKey] (IMPLEMENT MODE - Initial Validation)
        
        üìã –ú–û–Ø –ò–ù–¢–ï–†–ü–†–ï–¢–ê–¶–ò–Ø –ù–ê –û–°–ù–û–í–ï –û–ü–ò–°–ê–ù–ò–Ø –ò–ó JIRA:
        –°—É—Ç—å –∑–∞–¥–∞—á–∏: [implementation-focused understanding from currentDescription]
        –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: [code, tests, documentation needs from currentDescription]
        –û–∂–∏–¥–∞–µ–º–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è: [implementation deliverables from currentDescription]
        –°–ª–æ–∂–Ω–æ—Å—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏: [Level 1-4 with technical reasoning based on currentDescription]
        
        ‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π?
        üìù –ù—É–∂–Ω—ã —É—Ç–æ—á–Ω–µ–Ω–∏—è –≤ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (–±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–æ –≤ Jira)?
        üéØ –°–æ–≥–ª–∞—Å–Ω—ã —Å –æ—Ü–µ–Ω–∫–æ–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏?
        ```
    *   **Action**: Wait for user confirmation.
    *   **Condition**: If user requests changes to the understanding or specification:
        *   **Action**: Solicit refined details from the user for the Jira description.
        *   **Action**: Let `refinedDescription = user_provided_details`.
        *   **Action**: Let `aiEditedNoteForValidation = "\n\n–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –û–ø–∏—Å–∞–Ω–∏–µ —É—Ç–æ—á–Ω–µ–Ω–æ –ò–ò –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–µ—Ä–µ–¥ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏–µ–π."`. 
        *   Let `descriptionForUpdate = (activeProjectContext.jira_description_prefix || "") + refinedDescription + (activeProjectContext.jira_description_suffix || "") + aiEditedNoteForValidation`.
        *   Let `labelsForUpdate = currentLabels`. If `"edited-by-ai"` not in `labelsForUpdate`, add it. If `activeProjectContext.jira_default_labels` AND `activeProjectContext.jira_default_labels.task` exists, ensure they are in `labelsForUpdate`.
        *   Let `customFieldsForUpdate = {}`.
        *   Ask user: "–û–±–Ω–æ–≤–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –∏ –º–µ—Ç–∫–∏ –∑–∞–¥–∞—á–∏ [selectedJiraIssueKey] –≤ Jira –Ω–∞ –æ—Å–Ω–æ–≤–µ —ç—Ç–∏—Ö —É—Ç–æ—á–Ω–µ–Ω–∏–π?"
        *   If user agrees: Call `mcp_mcp-atlassian_jira_update_issue` for `selectedJiraIssueKey` (description `descriptionForUpdate`, labels `labelsForUpdate`). Update `currentDescription` and `currentLabels` with new values.
        *   Report success/failure of update.
    *   **Action**: (If complexity changed and SP re-estimation is needed based on `atlassian-integration.mdc` logic) Propose SP update in Jira using `mcp_mcp-atlassian_jira_update_issue` with the `activeProjectContext.jira_sp_field_id`.
*   **Report**: "AI –≤–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–¥–∞—á–∏ [selectedJiraIssueKey] –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ì–æ—Ç–æ–≤ –∫ —Å–æ–∑–¥–∞–Ω–∏—é –≤–µ—Ç–∫–∏ –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏."
```

#### 3.1.3 Archive Mode Map

**–§–∞–π–ª:** `.cursor/rules/isolation_rules/visual-maps/archive-mode-map.mdc`

**–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ —à–∞–≥–∏:**

1. **Step X.1: Create/Update Confluence Page:**
```markdown
### Step X.1: Create/Update Confluence Page (using `activeProjectContext.confluence_space_key`)
*   **Action**: Read the content of the local archive document: `localArchivePath = "docs/archive/[activeProjectContext.context_name]/[selectedJiraIssueKey].md"`. Let `pageContentForConfluence` be this content (ensure it is Confluence compatible, e.g. Markdown or converted to XHTML if necessary).
*   **Action**: Determine Confluence Space Key: `confluenceSpaceKey = activeProjectContext.confluence_space_key`.
    *   If `confluenceSpaceKey` is missing or invalid, report error and skip Confluence steps.
*   **Action**: Determine Parent Page ID: `parentPageId = activeProjectContext.confluence_parent_page_id_archive` (can be null).
*   **Action**: Construct Page Title: `pageTitle = activeProjectContext.confluence_archive_page_title_format` (e.g., "Archive: [selectedTask.title] ([selectedJiraIssueKey])" - replace placeholders with actual values).
*   **Action**: Check for Existing Page: Call `mcp_mcp-atlassian_confluence_get_page_by_title` with `space_key=confluenceSpaceKey` and `title=pageTitle`.
    *   Let `existingPage = result`.
*   **Condition**: If `existingPage` is found (e.g., `existingPage.id` exists):
    *   **Action**: Let `existingPageId = existingPage.id` and `existingVersionNumber = existingPage.version.number`.
    *   **Action**: Ask user: "Confluence page '[pageTitle]' (ID: [existingPageId]) already exists. Update it with new archive content?"
    *   **Condition**: If user agrees to update:
        *   **Action**: Call `mcp_mcp-atlassian_confluence_update_page` with `page_id=existingPageId`, `title=pageTitle` (usually kept same), `space_key=confluenceSpaceKey`, `body_content=pageContentForConfluence`, `version_number=existingVersionNumber + 1`.
        *   **Report**: "Confluence page [existingPageId] updated. URL: [page_url_from_response]". Store `confluencePageUrl`.
    *   **Condition**: Else (user declines update):
        *   **Report**: "Confluence page update skipped by user."
*   **Condition**: If `existingPage` is NOT found:
    *   **Action**: Call `mcp_mcp-atlassian_confluence_create_page` with `space_key=confluenceSpaceKey`, `title=pageTitle`, `body_content=pageContentForConfluence`, and `parent_id=parentPageId` (if `parentPageId` is not null).
    *   **Report**: "New Confluence page '[pageTitle]' created. URL: [page_url_from_response]". Store `confluencePageUrl`.
*   **Condition**: (After successful create/update) If `activeProjectContext.confluence_add_labels_on_archive` is true AND `activeProjectContext.confluence_default_archive_labels` (e.g., ["archive", "task-[selectedJiraIssueKey]"]) are defined:
    *   **Action**: Let `pageIdToLabel = newly_created_page_id` or `existingPageId`.
    *   **Action**: Call `mcp_mcp-atlassian_confluence_add_labels_to_content` with `page_id=pageIdToLabel` and `labels=activeProjectContext.confluence_default_archive_labels`.
    *   **Report**: "Labels added to Confluence page."
*   **Error Handling**: Report any errors from Confluence API calls.
```

2. **Step X.3: Update Jira Issue Status to Final:**
```markdown
### Step X.3: Update Jira Issue Status to Final (e.g., Closed/Archived from `activeProjectContext.jira_status_mapping`)
*   **Action**: Identify the final target status details from `activeProjectContext.jira_status_mapping.ARCHIVE`. This should provide `target_status_id` (preferred) or `target_status_name`, and `allowed_from_statuses_ids` or `allowed_from_statuses_names`.
    *   If mapping is incomplete, report error and skip Jira update or ask for manual confirmation of target status.
*   **Action**: Let `finalTargetStatusId = activeProjectContext.jira_status_mapping.ARCHIVE.target_status_id`.
*   **Action**: Let `finalTargetStatusName = activeProjectContext.jira_status_mapping.ARCHIVE.target_status_name`.
*   **Action**: Let `allowedFromStatuses = activeProjectContext.jira_status_mapping.ARCHIVE.allowed_from_statuses_ids` (or `_names`).
*   **Action**: Call `mcp_mcp-atlassian_jira_get_issue` for `selectedJiraIssueKey` to get `currentJiraStatusId` or `currentJiraStatusName`.
*   **Condition**: If `currentJiraStatusId` (or name) is NOT in `allowedFromStatuses`:
    *   **Report**: "WARNING: Current Jira status for [selectedJiraIssueKey] is '[currentJiraStatusName]'. This is not an allowed status to directly transition to '[finalTargetStatusName]'. An intermediate manual transition might be required."
    *   **Action**: Ask user if they want to attempt the transition anyway.
    *   If user declines, skip automated transition.
*   **Action**: (If proceeding) Call `mcp_mcp-atlassian_jira_transition_issue` with `issue_key=selectedJiraIssueKey` and `transition_id=finalTargetStatusId` (or `transition_name=finalTargetStatusName`).
*   **Report**: "Jira issue [selectedJiraIssueKey] transitioned to [finalTargetStatusName]."
*   **Condition**: If `activeProjectContext.jira_add_comment_on_archive` is true:
    *   **Action**: Let `archiveComment = activeProjectContext.jira_archive_comment_template` (e.g., "Task archived. See Confluence: [confluencePageUrl], GitLab Tag: [gitLabTagUrl]"). Replace placeholders.
    *   **Action**: Call `mcp_mcp-atlassian_jira_add_comment` with `issue_key=selectedJiraIssueKey` and `comment_body=archiveComment`.
    *   **Report**: "Comment added to Jira issue [selectedJiraIssueKey]."
*   **Condition**: If `activeProjectContext.jira_update_resolution_on_archive` is true AND `activeProjectContext.jira_resolution_name_for_archive` (e.g., "Done", "Fixed") is defined:
    *   **Action**: Call `mcp_mcp-atlassian_jira_update_issue_resolution` with `issue_key=selectedJiraIssueKey` and `resolution_name=activeProjectContext.jira_resolution_name_for_archive`.
    *   **Report**: "Resolution for Jira issue [selectedJiraIssueKey] set to '[activeProjectContext.jira_resolution_name_for_archive]'."
*   **Error Handling**: Report any errors from Jira API calls.
```

---

## 4. –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –ú–£–õ–¨–¢–ò–ö–û–ù–¢–ï–ö–°–¢–ù–û–ô –°–ò–°–¢–ï–ú–´ (`moar-logics/multi-context-system.mdc`)

### 4.1 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞

**–§–∞–π–ª:** `integration_config.md`

**–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ (–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞):**
```diff
+ --- 
+ description: "Central configuration for multi-project context, integrations (Jira, GitLab, Confluence, DeepSeek), and tool settings. The structure and usage of this file are governed by the .cursor/rules/isolation_rules/Core/multi-context-system.mdc rule."
+ globs: ["integration_config.md"]
+ alwaysApply: false
+ ---
+ 
+ # Integration & Project Context Configuration
+ 
+ > **IMPORTANT**: The structure, available fields, and logic for interpreting this configuration are defined in detail in the `.cursor/rules/isolation_rules/Core/multi-context-system.mdc` rule. Refer to it for comprehensive guidance on how to define and use project contexts and their specific settings.
+ 
  # Integration Configuration for Memory Bank System
  
  ## Project Contexts
```

---

## 5. –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –°–ò–°–¢–ï–ú–´ –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ó–ê–î–ê–ß–ê–ú–ò (`moar-logics/task-management.mdc`)

### 5.1 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–ª–∞–≤–Ω–æ–≥–æ README

**–§–∞–π–ª:** `README.md`

**–ö–æ–Ω—Ç–µ–∫—Å—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–¥–∞ (—Å–µ–∫—Ü–∏—è `## –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–∞–π–ª—ã –∏ –∏—Ö –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ`):**
```markdown
// ... (previous content of README.md) ...
## –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–∞–π–ª—ã –∏ –∏—Ö –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ

- **tasks.md**: –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∑–∞–¥–∞—á
- **activeContext.md**: –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–æ–∫—É—Å —Ç–µ–∫—É—â–µ–π —Ñ–∞–∑—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
// ... (other files) ...
```

**–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–ø–∏—Å–∞–Ω–∏—è `tasks.md`):**
```diff
 ## –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–∞–π–ª—ã –∏ –∏—Ö –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ
 
-- **tasks.md**: –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∑–∞–¥–∞—á
+- **tasks.md**: –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∑–∞–¥–∞—á. –ï–≥–æ —Ñ–æ—Ä–º–∞—Ç, –ø—Ä–∏–Ω—Ü–∏–ø—ã –≤–µ–¥–µ–Ω–∏—è –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —Å Jira –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –ø—Ä–∞–≤–∏–ª–æ–º `.cursor/rules/isolation_rules/Core/task-management.mdc`.
 - **activeContext.md**: –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–æ–∫—É—Å —Ç–µ–∫—É—â–µ–π —Ñ–∞–∑—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
```

---

## –ó–ê–ö–õ–Æ–ß–ï–ù–ò–ï –ò –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ò–ù–¢–ï–ì–†–ê–¶–ò–ò

### –î–æ—Å—Ç–∏–≥–Ω—É—Ç—ã–µ —Ü–µ–ª–∏:

1.  **‚úÖ –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è DeepSeek LLM** —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –≤—ã–±–æ—Ä–æ–º –º–æ–¥–µ–ª–∏ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫.
2.  **‚úÖ –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏** —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º —Å–æ–∑–¥–∞–Ω–∏–µ–º –±—ç–∫–∞–ø–æ–≤, –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –¥–æ—Å—Ç—É–ø–∞, –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ —Ñ–∞–π–ª–æ–≤, –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∏ –∞—É–¥–∏—Ç–æ–º –æ–ø–µ—Ä–∞—Ü–∏–π.
3.  **‚úÖ –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Atlassian (Jira/Confluence)**, –≤–∫–ª—é—á–∞—è –º—É–ª—å—Ç–∏–∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –∑–∞–¥–∞—á, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é Story Points, —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞–º–∏, —Å–æ–∑–¥–∞–Ω–∏–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü Confluence, –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –ø–æ–ª–µ–π Jira.
4.  **‚úÖ –£—Å–∏–ª–µ–Ω–∏–µ –º—É–ª—å—Ç–∏–∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã** –ø—É—Ç–µ–º —è–≤–Ω–æ–≥–æ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è `integration_config.md` —Å —É–ø—Ä–∞–≤–ª—è—é—â–∏–º –ø—Ä–∞–≤–∏–ª–æ–º.
5.  **‚úÖ –£–ª—É—á—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏** –ø—É—Ç–µ–º —è–≤–Ω–æ–≥–æ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è `tasks.md` —Å —É–ø—Ä–∞–≤–ª—è—é—â–∏–º –ø—Ä–∞–≤–∏–ª–æ–º –≤ `README.md`.

### –°–æ–∑–¥–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã:
*   `.cursor/rules/isolation_rules/Core/deepseek-integration.mdc`

### –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã:
*   `.cursor/rules/isolation_rules/Core/optimization-integration.mdc` (–ø—Ä–æ–≤–µ—Ä–µ–Ω–æ, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç)
*   `integration_config.md` (–¥–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ–ª—è –¥–ª—è DeepSeek, Jira, Confluence; –¥–æ–±–∞–≤–ª–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø—Ä–∞–≤–∏–ª–æ `multi-context-system.mdc`)
*   `README.md` (–¥–æ–±–∞–≤–ª–µ–Ω–∞ —Å–µ–∫—Ü–∏—è –ø—Ä–æ DeepSeek; –æ–±–Ω–æ–≤–ª–µ–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ `tasks.md`)
*   `.cursor/rules/isolation_rules/main.mdc` (—Ä–∞—Å—à–∏—Ä–µ–Ω–∞ —Å–µ–∫—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
*   `.cursor/rules/isolation_rules/Core/file-verification.mdc` (–¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞)
*   `.cursor/rules/isolation_rules/Core/command-execution.mdc` (–¥–æ–±–∞–≤–ª–µ–Ω –∞—É–¥–∏—Ç –æ–ø–µ—Ä–∞—Ü–∏–π)
*   `.cursor/rules/isolation_rules/visual-maps/plan-mode-map.mdc` (—É–ª—É—á—à–µ–Ω–∞ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Jira, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è SP)
*   `.cursor/rules/isolation_rules/visual-maps/implement-mode-map.mdc` (—É–ª—É—á—à–µ–Ω–∞ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Jira, AI –≤–∞–ª–∏–¥–∞—Ü–∏—è, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è SP)
*   `.cursor/rules/isolation_rules/visual-maps/archive-mode-map.mdc` (—É–ª—É—á—à–µ–Ω–∞ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Jira –∏ Confluence)

### –ö–ª—é—á–µ–≤—ã–µ —É–ª—É—á—à–µ–Ω–∏—è:
1.  **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å**: –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É—Å–∏–ª–µ–Ω–∞ –∑–∞ —Å—á–µ—Ç –Ω–æ–≤—ã—Ö –ø—Ä–æ—Ü–µ–¥—É—Ä –∏ –ø—Ä–æ–≤–µ—Ä–æ–∫.
2.  **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è**: –ì–ª—É–±–æ–∫–∞—è –∏ –≥–∏–±–∫–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏, –∞–¥–∞–ø—Ç–∏—Ä—É—é—â–∞—è—Å—è –∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –ø—Ä–æ–µ–∫—Ç–∞.
3.  **–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –∏ –ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å**: –£–ª—É—á—à–µ–Ω—ã –ø—Ä–æ—Ü–µ—Å—Å—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏.
4.  **–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å**: –ë–æ–ª–µ–µ —á–µ—Ç–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –∏ –∏—Ö —Å–≤—è–∑–µ–π —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–º–∏ —Ñ–∞–π–ª–∞–º–∏. 

–í—Å–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã —Å —Ü–µ–ª—å—é –ø–æ–≤—ã—à–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏, –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ —É–¥–æ–±—Å—Ç–≤–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã Memory Bank. 