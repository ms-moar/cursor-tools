---
description: Visual process map for VAN mode (Index/Entry Point)
globs: van-mode-map.mdc
alwaysApply: false
---
# VAN MODE: INITIALIZATION PROCESS MAP (INDEX)

> **TL;DR:** This is the entry point for VAN mode. It handles initial activation and directs the process to subsequent steps stored in separate files for optimization.

## üöÄ VAN MODE ACTIVATION

When the user types "VAN", respond with a confirmation and start the process:

```
User: VAN

Response: OK VAN - Beginning Initialization Process
Loading Platform Detection map...
```

## üß≠ VAN MODE PROCESS FLOW (High Level)

This graph shows the main stages. Each stage is detailed in a separate file loaded sequentially.

```mermaid
graph TD
    Start["VAN Mode Start"] --> AutoSync["Step 1: Auto-Sync Completed Tasks"]
    AutoSync --> TaskSelect["Step 2: Select Task for Initialization"]
    TaskSelect --> Complexity["Step 3: Determine Complexity"]
    Complexity --> SuggestNext["Step 4: Suggest Next Mode (PLAN/IMPLEMENT)"]
    SuggestNext --> End["VAN Mode End"]
```

**Next Step:** Load and process `van-platform-detection.mdc`. 

## DETAILED STEPS

### Step 1: Auto-Sync Completed Tasks

*   **Action**: Read `tasks.md` to identify tasks not marked as locally completed.
*   **Action**: For each such task ID found, call `mcp_mcp-atlassian_jira_get_issue` to check its current status in Jira.
*   **Condition**: If a task status in Jira is 'Done' (or configured equivalent final status) but not in `tasks.md`:
    *   **Action**: Propose an `edit_file` operation on `tasks.md` to update the status for that task ID.
    *   **Action**: Wait for user approval of the `edit_file` operation.
*   **Report**: Briefly report result (e.g., "–°—Ç–∞—Ç—É—Å—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã." –∏–ª–∏ "–ü—Ä–µ–¥–ª–æ–∂–µ–Ω—ã –ø—Ä–∞–≤–∫–∏ –¥–ª—è tasks.md.").

### Step 2: Select Task for Initialization

*   **Action**: Ask user: "–£ –≤–∞—Å –µ—Å—Ç—å ID –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∑–∞–¥–∞—á–∏ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏? –ï—Å–ª–∏ –¥–∞, —Å–æ–æ–±—â–∏—Ç–µ. –ò–Ω–∞—á–µ —è –ø–æ–∏—â—É –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –∑–∞–¥–∞—á–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ —Å—Ç–∞—Ç—É—Å–µ 'Backlog')."
*   **Condition**: If user provides an ID:
    *   Store the `issue_key`.
*   **Condition**: If user does not provide ID:
    *   **Action**: Call `mcp_mcp-atlassian_jira_search` with JQL like `status = Backlog AND (assignee = currentUser() OR assignee = EMPTY) ORDER BY updated DESC`, limit 5-10, fields=summary,status.
    *   **Action**: Present the list of found tasks to the user.
    *   **Action**: Ask user to select a task ID from the list.
    *   Store the selected `issue_key`.
*   **Error Handling**: If no task ID is provided or selected, report error and stop.
*   **Report**: Confirm selected task: "–í—ã–±—Ä–∞–Ω–∞ –∑–∞–¥–∞—á–∞ [issue_key] - [–ù–∞–∑–≤–∞–Ω–∏–µ]."

### Step 3: Determine Complexity

*   **Action**: Load and follow the logic from `.cursor/rules/isolation_rules/Core/complexity-decision-tree.mdc` using the selected task's details (summary, description if available).
*   **Action**: Record the determined Complexity Level (1-4) potentially in `activeContext.md` or as a variable.
*   **Report**: Inform user: "–û–ø—Ä–µ–¥–µ–ª–µ–Ω –£—Ä–æ–≤–µ–Ω—å –°–ª–æ–∂–Ω–æ—Å—Ç–∏: [Level] - [Description]."

### Step 4: Suggest Next Mode (PLAN/IMPLEMENT)

*   **Condition**: Based on the determined Complexity Level:
    *   If Level 1: Suggest `IMPLEMENT` mode.
    *   If Level 2-4: Suggest `PLAN` mode.
*   **Report**: "–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥: –†–µ–∂–∏–º [PLAN/IMPLEMENT]. –í–≤–µ–¥–∏—Ç–µ '[PLAN/IMPLEMENT]' –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞."

### Step 5: VAN Mode End

*   Wait for user command to transition to the next mode. 