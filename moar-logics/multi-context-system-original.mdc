---
description:
globs:
alwaysApply: false
---
# Мульти-контекстная система Memory Bank

## Основные принципы работы

### Автоматическое определение контекста проекта

**Алгоритм определения контекста:**
1. Анализ структуры директорий и файлов проекта
2. Поиск конфигурационных файлов (package.json, requirements.txt, etc.)
3. Определение языков программирования по расширениям файлов
4. Анализ содержимого README и документации
5. Проверка наличия специфических паттернов и фреймворков

**Приоритеты определения контекста:**
- **Высокий приоритет**: Конфигурационные файлы, манифесты проектов
- **Средний приоритет**: Структура директорий, основные файлы кода
- **Низкий приоритет**: Временные файлы, кэш, логи

**Типы контекстов проектов:**
1. **Web-разработка**: React, Vue, Angular, HTML/CSS/JS
2. **Backend**: Node.js, Python Django/Flask, Java Spring, .NET
3. **Mobile**: React Native, Flutter, iOS/Android нативные
4. **Desktop**: Electron, Qt, WPF, JavaFX
5. **Data Science**: Jupyter, Python с ML библиотеками
6. **DevOps**: Docker, Kubernetes, CI/CD конфигурации

**Индикаторы типов проектов:**
```
Web: package.json + react/vue/angular зависимости
Backend: requirements.txt/pom.xml + серверные фреймворки
Mobile: android/, ios/, pubspec.yaml, react-native
Desktop: main.py + tkinter/qt, .csproj + WPF
Data Science: .ipynb файлы, pandas/numpy/sklearn
DevOps: Dockerfile, docker-compose.yml, .gitlab-ci.yml
```

### Переключение между контекстами

**Процедура переключения контекста:**
1. Сохранение текущего состояния активного контекста
2. Валидация целевого контекста и его доступности
3. Загрузка конфигурации и настроек целевого контекста
4. Обновление переменных окружения и путей
5. Инициализация специфических для контекста инструментов
6. Уведомление пользователя об успешном переключении

**Автоматические триггеры переключения:**
- Открытие файла из другого проекта
- Выполнение команды в другой директории
- Явное указание контекста в команде
- Обнаружение изменений в структуре проекта

**Правила изоляции контекстов:**
- Каждый контекст имеет собственное пространство переменных
- История команд и настройки изолированы между контекстами
- Кэш и временные файлы разделены по контекстам
- Логи и метрики ведутся отдельно для каждого контекста

### Управление конфигурациями

**Структура конфигурации контекста:**
```json
{
  "context_id": "project-web-frontend",
  "name": "Frontend Web Application",
  "type": "web",
  "root_path": "/path/to/project",
  "languages": ["javascript", "typescript", "css"],
  "frameworks": ["react", "webpack", "jest"],
  "tools": {
    "package_manager": "npm",
    "bundler": "webpack",
    "testing": "jest",
    "linting": "eslint"
  },
  "environment": {
    "NODE_ENV": "development",
    "PORT": "3000"
  },
  "scripts": {
    "start": "npm start",
    "build": "npm run build",
    "test": "npm test"
  }
}
```

**Автоматическая генерация конфигураций:**
- Сканирование проекта при первом обнаружении
- Анализ зависимостей и инструментов
- Создание базовой конфигурации с возможностью кастомизации
- Обновление конфигурации при изменениях в проекте

**Наследование конфигураций:**
- Базовые шаблоны для типов проектов
- Переопределение специфических настроек
- Возможность создания пользовательских шаблонов
- Версионирование конфигураций

### Синхронизация данных между контекстами

**Общие данные между контекстами:**
- Глобальные настройки пользователя
- Общие инструменты и утилиты
- Кэш пакетов и зависимостей
- История глобальных команд

**Изолированные данные:**
- Локальные настройки проекта
- Специфические зависимости
- Временные файлы и кэш проекта
- Логи выполнения команд

**Алгоритм синхронизации:**
1. Определение типа данных (общие/изолированные)
2. Проверка конфликтов при синхронизации
3. Применение стратегии разрешения конфликтов
4. Обновление данных в соответствующих контекстах
5. Логирование изменений для отката

**Стратегии разрешения конфликтов:**
- **Приоритет локального**: Локальные настройки имеют приоритет
- **Приоритет глобального**: Глобальные настройки перезаписывают локальные
- **Слияние**: Объединение настроек с сохранением уникальных значений
- **Запрос пользователя**: Интерактивное разрешение конфликтов

### Кросс-контекстные операции

**Типы кросс-контекстных операций:**
1. **Копирование файлов**: Перенос файлов между проектами
2. **Синхронизация настроек**: Применение настроек к нескольким контекстам
3. **Общие команды**: Выполнение команд во всех активных контекстах
4. **Агрегация данных**: Сбор информации из всех контекстов

**Безопасность кросс-контекстных операций:**
- Проверка прав доступа к целевому контексту
- Валидация совместимости операции с типом контекста
- Предупреждения о потенциальных конфликтах
- Возможность отката операций

**Примеры кросс-контекстных команд:**
```bash
# Копирование конфигурации ESLint между проектами
mb copy-config eslint from:project-a to:project-b

# Выполнение тестов во всех проектах
mb run-all test

# Синхронизация зависимостей
mb sync-deps --pattern="@types/*"

# Агрегация статистики по всем проектам
mb stats --all-contexts
```

### Мониторинг и аналитика контекстов

**Метрики производительности:**
- Время переключения между контекстами
- Частота использования каждого контекста
- Количество кросс-контекстных операций
- Эффективность кэширования по контекстам

**Аналитика использования:**
- Самые активные проекты и контексты
- Паттерны переключения между контекстами
- Часто используемые команды в каждом контексте
- Время работы в каждом контексте

**Структура лога активности:**
```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "action": "context_switch",
  "from_context": "project-backend",
  "to_context": "project-frontend",
  "switch_time_ms": 150,
  "trigger": "file_open",
  "user_id": "user123"
}
```

**Отчеты и визуализация:**
- Ежедневные сводки активности по контекстам
- Графики использования проектов во времени
- Анализ эффективности работы с множественными контекстами
- Рекомендации по оптимизации workflow

### Оптимизация производительности

**Стратегии оптимизации:**
1. **Ленивая загрузка**: Загрузка контекста только при необходимости
2. **Предварительное кэширование**: Подготовка часто используемых контекстов
3. **Умное переключение**: Минимизация времени переключения
4. **Оптимизация памяти**: Выгрузка неактивных контекстов

**Кэширование контекстов:**
- Кэш конфигураций для быстрого доступа
- Предварительная компиляция настроек
- Кэширование результатов анализа проектов
- Инкрементальное обновление кэша

**Алгоритм управления памятью:**
```
Активный контекст (полная загрузка)
↓
Недавно использованные (частичная загрузка)
↓
Редко используемые (только метаданные)
↓
Неактивные (выгружены из памяти)
```

### Интеграция с внешними системами

**Поддерживаемые системы:**
- **Git**: Автоматическое определение репозиториев и веток
- **Docker**: Интеграция с контейнерами и образами
- **IDE**: Синхронизация с настройками редакторов
- **CI/CD**: Интеграция с пайплайнами сборки

**Автоматическая синхронизация:**
- Обновление контекста при изменении Git ветки
- Синхронизация с Docker Compose конфигурациями
- Импорт настроек из IDE конфигураций
- Мониторинг изменений в CI/CD файлах

**API для внешних интеграций:**
```javascript
// Получение информации о контексте
const context = await mb.getContext('project-name');

// Переключение контекста
await mb.switchContext('project-name');

// Выполнение команды в контексте
const result = await mb.runInContext('project-name', 'npm test');

// Создание нового контекста
await mb.createContext({
  name: 'new-project',
  type: 'web',
  path: '/path/to/project'
});
```

Данная система обеспечивает эффективное управление множественными контекстами проектов с автоматизацией переключений и поддержанием изоляции между различными рабочими средами.
